#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "GRSS-IR"
  https://create.arduino.cc/cloud/things/d16a6958-fe15-400b-876a-d256795f709d

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String nMEAStrings;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <SD.h>

#define GPS_BAUD_RATE 38400
#define SERIAL_BAUD 9600

#define IDLE_THRESHOLD 10 //milliseconds

#define SDCard 4

#define WAIT_FOR_VALID_GPS

#define MAX_BASENAME_LEN (8+1) // FAT limit 8.3, +1 for \0 char
#define MAX_FILENAME_LEN (MAX_BASENAME_LEN + 1 + 3) // basename + dot + extension

#define DEBUG // if defined will output debug messages to Serial

#define GPS_ACTIVE // if defined will wait for active GPS before writing

unsigned long bufferTime = millis();

String gpsBuffer = ""; // holds incoming NMEA sentences

void setup() {
    // Initialize serial and GPS serial
    Serial.begin(SERIAL_BAUD);
    Serial1.begin(GPS_BAUD_RATE);
    // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
    delay(1500);

    initProperties();

    // Connect to Arduino IoT Cloud
    // ArduinoCloud.begin(ArduinoIoTPreferredConnection, false);
    //
    // setDebugMessageLevel(2);
    // ArduinoCloud.printDebugInfo();

    // Setup sd card
    initSD();
}

void loop() {
    read_serial();
    bool GPSActive;
    char dateTime[6+6+1]; //yyyymmDDHHMMSS\0
    char basename[MB_LEN_MAX];
    unsigned long startTime = millis();

    unsigned long idleTime = startTime - bufferTime;
    if (idleTime < IDLE_THRESHOLD || gpsBuffer.length() < 3) {return;}

    #ifdef DEBUG
        Serial.println("[DEBUG] starting SD log");
        Serial.println(gpsBuffer);
    #endif

    GPSActive = getDateTime(gpsBuffer.c_str(), dateTime);
    // ArduinoCloud.push();
    gpsBuffer = "";
}

/*
  Since NMEAStrings is READ_WRITE variable, onNMEAStringsChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onNMEAStringsChange()  {
    // Add your code here to act upon NMEAStrings change
}

bool initSD() {
    if (!SD.begin(SDCard)) {
        Serial.println("[ERROR] Unable to init SD Card!");
        return false;
    }
    return true;
}


bool getDateTime(const char stringOriginal[], char dateTime[]) {
    char strTemp[82];
    char *gnrmc_str = nullptr;
    char *gnrmc_end = nullptr;

    const char *dateIn;
    const char *timeIn;
    int len;

    if (strlen(stringOriginal) == 0) {
#ifdef DEBUG
        Serial.println("[DEBUG] Empty string");
#endif
        return false;

    }
    gnrmc_str = strstr(stringOriginal, "$GNRMC");
    if (!gnrmc_str) {
#ifdef DEBUG
        Serial.println("[DEBUG] $GNRMC NMEA sentence not found!");
#endif
        return false;
    }
    if (gnrmc_str[17] != 'A') {
#ifdef DEBUG
        Serial.println("[DEBUG] GPS is not active yet!");
#endif
        return false;
    }

    gnrmc_end = strchr(gnrmc_str, '\n');
    len = (gnrmc_end - gnrmc_str) + 1;
    strncpy(strTemp, gnrmc_str, min(len, sizeof(strTemp)-1));
    strTemp[len] = '\0';

    dateIn = nth_strchr(strTemp, ',', 9) + 1;
}

///
/// Runs inbetween loops everytime a new character is available at Serial1
void read_serial() {
    while (Serial1.available()) {
        const char c = Serial1.read();
        gpsBuffer += c;
        bufferTime = millis();
    }
}